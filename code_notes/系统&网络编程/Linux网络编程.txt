1,四层模型
应用层       应用程序负责处理逻辑
传输层       client <---> server通信，采用tcp或udp协议
网络层       控制路由，节点选择
数据链路层   物理连接 IP <---> Mac地址

2，ping是应用程序，利用ICMP报文检测网络连接

3,访问DNS服务器的客户端程序是host

4,IP协议，为上层协议提供无状态，无连接，不可靠的服务。IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址，目的端IP地址，指导IP分片和重组等。IP协议还负责IP数据报的路由和转发

5，TCP协议，相对于UDP协议，TCP协议面向连接，字节流和可靠传输。
TCP连接是全双工的，是一对一的
TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号，目的端端口号。
TCP连接的两端都是状态机。TCP数据流的控制，超时重传和拥塞控制。

6，机器字节序分大端字节序和小端字节序，大端字节序表示高八位存储在低位地址，低八位存储在高位地址，网络字节序是大端字节序

7,网络编程相关命令，netstat查看TCP/IP网络的socket连接信息

在代码层面对socket的理解
利用系统调用 socket()，它返回套接字描述符 (socket descriptor)，这是一个无符号整数，然后再通过它来进行send() 和 recv()调用

socket地址API.网络到本机和本机到网络的字节顺序转换
htons(),h-to-n-s,Host to Network Short,本机到网络字节顺序转换
htonl(),h-to-n-s,Host to Network Long,本机到网络字节顺序转换
ntohs(),n-to-h-s,Network to Host Short
ntohl(),n-to-h-l,Network to Host Long

IP点数和字符串相互转换
ip2string:inet_addr(),将用点分十进制字符串表示的IPv4地址转换为用网络字节序整数表示的IPv4
string2ip:inet_ntoa(),上个函数逆作用

面向连接的数据报套接字流程TCP
socket()
bind()
listen()
accept()
send(),recv()数据读写

无连接的数据报套接字流程UDP
socket()
bind()
listen()
accept()
sendto(),recvfrom()数据读写

其他函数
close(),shutdown()关闭套接字，close实际是引用计数减一，shutdown是强制关闭
getpeername() 告诉你在连接的流式套接字上谁在另外一边
gethostname() 返回你程序所运行的机器的主机名字

高级I/O函数
1.单向管道  int pipe(int fd[2]),管道内部传输的数据是字节流
双向管道 int socketpair(...)
2.重定向标准I/O，dup和dup2
3.readv分散读数据，从文件描述符到分散内存，writev集中写数据，从分散内存集中写到文件描述符
4.sendfile在两个文件描述符直接传递数据，效率高
5.mmap申请内存，munmap释放内存。这段内存可以作为进程间内存共享，也可将文件直接映射其中
6.splice用于两个文件描述符之间直接移动数据，零拷贝操作
7.tee用于两个管道文件描述符之间复制数据，零拷贝操作
8.fcntl用于提供文件描述符各种控制操作

阻塞和非阻塞的应用一般用于服务器端，而同步和异步的操作一般用于客户端

在理论层面对socket,TCP/IP,HTTP的理解
1.OSI（Open System Interconnect），即开放式系统互联。一般都叫OSI参考模型，该体系结构标准定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层）
2.IP协议对应于网络层，TCP协议对应于传输层，主要解决数据如何在网络中传输，HTTP协议对应于应用层，主要解决如何包装数据
3.socket是对TCP/IP协议的封装和应用，本身不是协议，而是一个调用接口(API)，socket可以创建TCP或者UDP连接，socket实际上是为了实现通信而建立起来的通信管道，其真实的代表是客户端和服务端的一个通信进程，双方进程通过socket进行通信。
4.TCP连接的三次握手
	第一次：客户端发送SYN包到服务器，进入SYN_SEND状态，等待服务器确认
	第二次：服务器收到SYN包，并发送SYN+ACK包，进入SYN_RECV状态
	第三次：客户端收到SYN+ACK包，向服务器发送确认包ACK，之后，完成三次握手
5.利用socket建立网络连接的步骤
	建立socket连接至少需要一对套接字，客户端ClientSocket和服务器端ServerSocket
	套接字直接的连接分为三个步骤：服务器监听，客户端请求，连接确认
	1.服务器监听：等待连接的状态，实时监控网络状态，等待客户端的连接请求
	2.客户端请求：客户端的套接字提出连接请求(套接字必须描述需要连接的服务器的套接字，指出服务器套接字的地址和端口号)
	3.连接确认：服务器接收到客户端套接字的连接请求时，响应请求，建立一个新的线程，并将服务器端套接字的描述发给客户端，客户端确认此描述，正式建立连接
6.HTTP特点
	1.支持客户/服务器模式
	2.灵活：HTTP允许传输任意类型的数据对象
	3.无连接：限制每次连接只处理一个请求，即服务器处理完客户请求，并收到客户的应答后，立即断开连接。这种方式可以节省传输时间
	4.无状态：对于事务处理没有记忆能力
	5.简单快速：客户向服务器请求服务时，只需传送请求方法和路径
7.HTTP URL 格式  http://host[":"port][abs_path]   host表示合法的Internet主机域名或IP地址，port指定一个端口，abs_path指定请求资源的URI
8.HTTP1.1版本比起HTTP1.0版本最大的区别就是允许多个HTTP请求复用一个TCP连接，以加快传输速度
9.HTTP请求
	步骤1：浏览器向服务器发送HTTP请求，请求包括方法、路径、域名，以及其他相关的Header，如果方法的POST,那么请求还包括一个Body，包含用户数据
	步骤2：服务器向浏览器返回HTTP响应，响应包括响应代码、响应类型，以及其他相关的Header，通常服务器的HTTP响应会携带内容，也就是一个Body，包含响应的内容
	步骤3：如果浏览器还需要继续向服务器请求其他资源，就再次发出HTTP请求，重复步骤1、2
	


论述几种类型服务器的区别
1.阻塞型服务器，适用于单客户连接
2.非阻塞型服务器,当需要处理多个客户的连接请求时，一般会在服务器端使用多线程(或多进程)，但是当多客户超过三位数时，这种方法也开始不能正常工作，需要使用线程池或连接池，但此种方法也不适用于高并发服务器
2.1非阻塞I/O通常需要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号
3.IO复用事件驱动服务器模型
3.1 应用于Windows上的select事件驱动和应用于Linux上的poll不被推荐使用，不满足高并发需求，而epoll是poll的改版，是一个可行的办法
3.2 常见的将select或epoll封装了的库有libevent和libev
4.阻塞和非阻塞的说法是对于调用者来说，而同步和异步的说法是对于被调用者来说的。异步一般配合非阻塞使用



几种I/O模型分析
1.同步I/O要求用户在应用程序中自行进行I/O操作，同步I/O是内核向应用程序发送I/O准备就绪信号。
2.而异步I/O，实际上由内核完成I/O操作，完成之后由内核向应用程序发送I/O操作完成信号。异步I/O的读写操作总是立即返回，而不管I/O是否是阻塞的
3.理论上说，阻塞I/O，I/O复用，和信号驱动I/O都是同步I/O，



高并发编程适用于I/O密集型任务(例如数据库读写，文件读写等)，而不适用于计算密集型任务，并发编程主要有多进程和多线程两种，下面是两种高效的并发模式
1.半同步/半异步模式
2.领导者/追随者模式
